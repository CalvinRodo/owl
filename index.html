<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
<!--H2: Lato, 36px, bold
H3: Lato, 24px, bold
H4: Lato, 22px, bold
H5: Lato, 20px, bold
H6: Lato, 19px, plain text
Body: Noto sans, 20px, plain text  -->
    <style>
      @import url('https://fonts.googleapis.com/css?family=Lato|Noto+Sans&display=swap');

      body { font-family: 'Noto Sans', sans-serif; font-size: 20px; }
      h1 {  font-family: 'Lato', sans-serif; border-bottom: 1px solid #af3c43; font-size: 38px; font-weight:bold }
      h2 { font-family: 'Lato', sans-serif; font-size: 36px; font-weight: bold }
      h3 { font-family: 'Lato', sans-serif; font-size: 24px; font-weight: bold }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .whoah { color: #d3080c }
      .okay { color: #26374A }
    </style>
  </head>
  <body>
    <textarea id="source">

class: middle

# How to Draw an Owl 

## A Pragmatic Approach to Continuous Integration and Continuous Delivery

---

class: middle

## What is .okay[Continuous Integration]?

???

Continuous Integration (CI) is the practice of merging all developers' working copies to a shared mainline several times a day.

---

class: middle

## What is .okay[Continuous Delivery]?

???

Continuous Delivery is a software engineering approach in which teams produce software in short cycles, ensuring that the software can be reliably released at any time and, when releasing the software, doing so manually.

It's the same thing as Continous Deployment, in both we have a deployable product at the end.

Whether you trust the process enough to remove the human element from deploying or not is really irrelevant to the work that needs to be done.

---

# How to Draw an Owl

.center[![Text: How to draw an owl. The picture contains two images one is of two circles, ](/rCr9A.png)]

1. Draw two circles
2. Draw the rest of the f\*\*\*\*\*\* owl

???

How many people have seen this meme. 

When you talk to folks about the abilty to check in a line of code, have it checked and validated using both automated processes and manual code reviews by your co-workers then automatically deployed to a production environment.

It can feel a lot like this. 

I'm here to argue for a pragmatic approach using open source tools that we can start using today that will allow us to quickly move to the cloud.

I can't take credit saw this idea in a presentation from DevOpsDays Toronto

---

# How to do CI/CD in two easy steps

--

## 1. Check in some code.

???

Check some code into source control

--

## 2. Do all of your current manual processes automatically.

??? 

Just do everything you currently do but automate it.

---

class: middle

## Step 1: Use .okay[Git].

???

Everyone else is using it. 

All of the good tools are being built to integrate with it. 

It's easier to use learn it than it will be to get some things working without it

---

class: middle

## Step 2: Pick a CI/CD Tool.

---

class: middle, center

## Which .okay[Tool]? 

---

class: middle, center

## Doesn't Matter.

???

Pick the easiest one or the one you are comfortable with. 

Essentially they all do the same thing just run commands on a computer somewhere.

Have Azure use Azure DevOps Pipelines, Have GCP use Google Cloud Build, Have Aws use Code Pipeline or Code Build, have GitLab use GitLab CI/CD


---

class: middle

## But what if we can't decide which is best?

---

class: middle

## Should we setup a .okay[Working Group]? 

---

class: middle, center

## .whoah[**No**]

???

Flip a coin, or just try one out and if it sucks don't use it switch to another.

A working group is not going to get you the answer 


---

class: middle

## Step 3: Automate a .okay[Thing]

???

Start building those feedback loops

---

class: middle, center

## Which .okay[Thing]?

---

class: middle, center

## The .okay[Easiest].

???

Have automated unit tests uses those.

Have automated end to end tests use those. 

Greenfield project? Use linters. 

Have nothing well write one test or pick one linter and use that.

---


## Pick one of the following: 

- Secret Checking
- Security scanning
- Linting
- Test Automation
- Static Analysis
- Dynamic Analysis

--

### Pick the easiest

--

### Congrats you are on your way

---

# Secret Checking 

--

## 18f/git-seekret

--

## yelp/detect-secret

---

# Linting

--

## Pick rules that work for you. 

--

### Just pick a standard that someone else has chosen

--

### It's __really__ not worth doing anything else

--

### If you have arguments flip a coin.

--

### Stop Bikeshedding

???

Discusion over Small details overwhelm those over big details.
Everyone has an opinion.

---

# Security Scanning

--

## Do everything that you can without slowing down your builds too much


--

## Have a second CI Pipeline that does everything .footnote[.red.bold[*] Important footnote]
 

--

## Optimize for speed. Have the ability to fix things fast to reduce the impact when things break. Also do smaller pieces of work so that there is less chance of things breaking.

---

# Free security scanning tools

--

## OWASP Zed Attack Proxy

--

## Owasp Glue

---

# Automated Tests

--

## Unit Tests Just do them

--

## e2e Tests

--

## Do most of them in Cypress

--

## If you have the time write smoke tests in selenium

--

## If you have the patience use something like Cucumber
### * Personally I can't bother setting this up.

---

# What next?

--

## Automate whatever you can think of. 

--

- Bundle Sizes
- Time to Interaction
- Image Compression
- Spell Checking
- Translations
- ALL THE THINGS.


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>